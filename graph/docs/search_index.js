var documenterSearchIndex = {"docs":
[{"location":"arbx.html","page":"ArbX (Main)","title":"ArbX (Main)","text":"CurrentModule = ArbX","category":"page"},{"location":"arbx.html#ArbX-(Main)","page":"ArbX (Main)","title":"ArbX (Main)","text":"","category":"section"},{"location":"arbx.html","page":"ArbX (Main)","title":"ArbX (Main)","text":"Documentation for ArbX.","category":"page"},{"location":"arbx.html","page":"ArbX (Main)","title":"ArbX (Main)","text":"Pages = [\"arbx.md\"]","category":"page"},{"location":"arbx.html","page":"ArbX (Main)","title":"ArbX (Main)","text":"Modules = [ArbX]","category":"page"},{"location":"arbx.html#ArbX.LOCK","page":"ArbX (Main)","title":"ArbX.LOCK","text":"LOCK\n\nUseful for avoiding race conditions in setting prices in the MetaDiGraph\n\nThree scenarios: \n\nZero price currently set: Allow any market to set the price.\nSame Market Update: Update the price, but not the AMM.\nNew Market Update: Compare price and set the better one.\n\nAll 3 scenarios are in a race condition to set the price: for example, at zero price  Orca and Serum both send price updates; without acquiring lock, it's difficult to determine which of these prices will be set first. \n\n\n\n\n\n","category":"constant"},{"location":"arbx.html#ArbX.extracttokens-Tuple{Vector{<:AbstractString}}","page":"ArbX (Main)","title":"ArbX.extracttokens","text":"extracttokens(wrapped_tokens::Vector{<:AbstractString})::Vector{Token}\n\nReturn a vector of Token objects extracted from wrapped_tokens, storing different pairs for a token  internally in the object to yield only one unique representation.\n\n\n\n\n\n","category":"method"},{"location":"arbx.html#ArbX.initgraph-Tuple{Bool}","page":"ArbX (Main)","title":"ArbX.initgraph","text":"initgraph(probe::Bool) -> PairMultigraph, MetaDiGraph, Vector{AbstractString}, Tuple{DataFeed...}\n\nInitialize the graphs. If probe is true, then check for activity on each pair of every market integrated with the platform.  Return the graphs, tokens detected, and the feeds.\n\n\n\n\n\n","category":"method"},{"location":"arbx.html#ArbX.tometadigraph-Tuple{Multigraphs.WeightedDiMultigraph}","page":"ArbX (Main)","title":"ArbX.tometadigraph","text":"tometadigraph(pmg::PairMultigraph) -> MetaDiGraph\n\nReturn a MetaDiGraph constructed with the best weights from PairMultigraph. All fields of PriceData are serialized into the MetaDiGraph with corresponding symbol names.\n\nExamples\n\njulia> pmg, _ = topairmultigraph(Data)\n\njulia> g = tometadigraph(pmg)\n\njulia> get_prop(g, 38, 86, :side)\nbid::Side = 0\n\n\n\n\n\n","category":"method"},{"location":"arbx.html#ArbX.topairmultigraph-Tuple","page":"ArbX (Main)","title":"ArbX.topairmultigraph","text":"topairmultigraph(markets...)\n\nReturn a PairMultigraph and unique tokens for a given tuple of AMMs and their pairs.\n\nMarkets expected to be in the form: \n\n[(RAY, Vector{String}[\"BTC/USDT\", \"ETH/USDT\", \"SOL/USDT\"]), (SOL, Vector{String}[\"BTC/USDT\", \"ETH/USDT\", \"RAY/USDT\"]) ...]\n\n\n\n\n\n","category":"method"},{"location":"arbx.html#ArbX.topairmultigraph-Tuple{DataFrames.DataFrame}","page":"ArbX (Main)","title":"ArbX.topairmultigraph","text":"topairmultigraph(df::DataFrame)\n\nReturn a PairMultigraph constructed from a DataFrame with the required fields.  Check ArbX.Data for the format. \n\n\n\n\n\n","category":"method"},{"location":"arbx.html#ArbX.topairmultigraph-Tuple{String, Vararg{Any}}","page":"ArbX (Main)","title":"ArbX.topairmultigraph","text":"topairmultigraph(filterby::String, markets...)\n\nReturn a PairMultigraph and unique tokens for a given tuple of AMMs and their pairs.  Only tokens found in the filterby AMM are preserved.\n\nMarkets expected to be in the form: \n\n[(RAY, Vector{String}[\"BTC/USDT\", \"ETH/USDT\", \"SOL/USDT\"]), (SOL, Vector{String}[\"BTC/USDT\", \"ETH/USDT\", \"RAY/USDT\"]) ...]\n\n\n\n\n\n","category":"method"},{"location":"arbx.html#ArbX.topairmultigraph-Tuple{Vector{<:AbstractString}, AbstractString}","page":"ArbX (Main)","title":"ArbX.topairmultigraph","text":"topairmultigraph(mkts::Vector{<:AbstractString}, amm::AbstractString)\n\nReturn a PairMultigraph and unique tokens from given pairs and AMM. \n\n\n\n\n\n","category":"method"},{"location":"arbx.html#ArbX.tosimpleweightedgraph-Tuple{Multigraphs.WeightedDiMultigraph}","page":"ArbX (Main)","title":"ArbX.tosimpleweightedgraph","text":"tosimpleweightedgraph(pmg::PairMultigraph) -> PairMultigraph\n\nReturn a condensed form of a weighted multigraph with only one weight per edge. \n\nExamples\n\njulia> using ArbX, Multigraphs\njulia> data(x,y) = ArbX.Types.PriceData(x, y, 10.0, \"SRM\")\ndata (generic function with 1 method)\n\njulia> wmg = WeightedDiMultigraph(\n                       Dict(\n                          1 => [2, 2, 3],\n                          2 => [1, 3, 4],\n                          3 => [1, 2, 4],\n                          4 => [2, 3]\n                      ),\n                      Dict(\n                          1 => [data(bid, 1.28), data(bid, 1.3), data(ask, 0.56)],\n                          2 => [data(ask, 1.29), data(bid, 1.43), data(bid, 1.51)],\n                          3 => [data(bid, 0.55), data(ask, 1.44), data(ask, 0.96)],\n                          4 => [data(ask, 1.52), data(bid, 0.95)]\n                      )\n                  )\n{4, 10} directed Int64 multigraph\n\njulia> pmg = tosimpleweightedgraph(wmg)\n{4, 10} directed Int64 multigraph\n\njulia> mul(pmg, 1, 2)\n1\n\njulia> mul(wmg, 1, 2)\n2\n\n\n\n\n\n","category":"method"},{"location":"arbx.html#Base.setindex!-Tuple{MetaDiGraph, Vector{ArbX.Types.Token}, ArbX.Types.DataPacket}","page":"ArbX (Main)","title":"Base.setindex!","text":"setindex!(mdg::MetaDiGraph, tokens::Vector{<:AbstractString}, packet::DataPacket)\n\nUpdate and return the indices of the nodes in the graph corresponding to the tokens in the packet. Specialized for MultiDiGraph. Compares current price with new price and updates the edge weight if the new price is better.\n\nNote: For correctness and speed reasons, tokens MUST be lowercased.\n\n\n\n\n\n","category":"method"},{"location":"arbx.html#Base.setindex!-Tuple{Multigraphs.WeightedDiMultigraph, Vector{ArbX.Types.Token}, ArbX.Types.DataPacket}","page":"ArbX (Main)","title":"Base.setindex!","text":"setindex!(pmg::PairMultigraph, tokens::Vector{<:AbstractString}, packet::DataPacket)\n\nUpdate and returns the indices of the nodes in the graph corresponding to the tokens in the packet.\n\nNote: For correctness and speed reasons, tokens MUST be lowercased.\n\n\n\n\n\n","category":"method"},{"location":"arbitrage.html","page":"Arbitrage","title":"Arbitrage","text":"CurrentModule = ArbX.Arbitrage","category":"page"},{"location":"arbitrage.html#Arbitrage","page":"Arbitrage","title":"Arbitrage","text":"","category":"section"},{"location":"arbitrage.html","page":"Arbitrage","title":"Arbitrage","text":"Documentation for ArbX.","category":"page"},{"location":"arbitrage.html","page":"Arbitrage","title":"Arbitrage","text":"Pages = [\"arbitrage.md\"]","category":"page"},{"location":"arbitrage.html","page":"Arbitrage","title":"Arbitrage","text":"Modules = [Arbitrage]","category":"page"},{"location":"arbitrage.html#ArbX.Arbitrage.bellman_ford_return_cycle-Union{Tuple{T}, Tuple{MetaDiGraph, T}} where T<:Integer","page":"Arbitrage","title":"ArbX.Arbitrage.bellman_ford_return_cycle","text":"bellman_ford_return_cycle(graph::MetaDiGraph, s::T) where T<:Integer\n\nReturn a tuple of distances, predecessors and vector of cycles in the graph if they exist,  otherwise returns an empty vector in the third position. \n\n\n\n\n\n","category":"method"},{"location":"arbitrage.html#ArbX.Arbitrage.calculate_profit_potential-Tuple{MetaDiGraph, Vector{<:Integer}}","page":"Arbitrage","title":"ArbX.Arbitrage.calculate_profit_potential","text":"calculate_profit_potential(mdg::MetaDiGraph, cycle::Vector{<:Integer})\n\nCalculate a profit potential from the given cycle and the graph. \n\nFormula\n\nbeginaligned\nprofit_potential(mdg cycle) = prod_n=1^length(cycle) - 1\n         begincases\n           textprice(mdg n n + 1)^-1 textif side(mdg n n + 1) = ask\r\n           textprice(mdg n n + 1) textif side(mdg n n + 1) = bid\r\n         endcases\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"arbitrage.html#ArbX.Arbitrage.extractarb-Tuple{MetaDiGraph, Vector{<:Integer}}","page":"Arbitrage","title":"ArbX.Arbitrage.extractarb","text":"extractarb(mdg::MetaDiGraph, cycle::Vector{<:Integer}, tokens::Vector{<:AbstractString})\n\nReturn a Dict containing arbitrage information extracted from the cycle. \n\nThe Dict contains the following attributes:\n\nprofit_potential::Float64 : A floating-point number indicating the expected profit. See also calculate_profit_potential.\ntokens::Vector{AbstractString} : List of tokens that form the cycle.\ntrades::Vector{AbstractString} : List of trade sides (ask or bid) indicating the direction of the swap.\nprices::Vector{Float64} : List of prices at the time of arbitrage detection. Ask prices are reciprocated.\nvolumes::Vector{Float64} : List of volumes available at the price levels given in prices.\nmarkets::Vector{AbstractString} : List of markets (DEX or AMM) that participate in the arbitrage. The n-th swap should be performed on the n-th market.\ntimestamp::DateTime : Timestamp at the time of arb extraction (computed internally to avoid collisions abroad).\n\n\n\n\n\n","category":"method"},{"location":"arbitrage.html#ArbX.Arbitrage.find2arb-Tuple{Multigraphs.WeightedDiMultigraph, Vararg{Int64}}","page":"Arbitrage","title":"ArbX.Arbitrage.find2arb","text":"find2arb(pmg::PairMultigraph, tokens::Vector{<:AbstractString}, ids::Vararg{Int64})\n\nFind the arbitrage opportunities in the PairMultigraph such that the best bid on a market is greater than the best ask on any other. The scanning is performed on the indexes ids of tokens only.  \n\n\n\n\n\n","category":"method"},{"location":"index.html","page":"Home","title":"Home","text":"CurrentModule = ArbX","category":"page"},{"location":"index.html#ArbX","page":"Home","title":"ArbX","text":"","category":"section"},{"location":"index.html#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\"arbx.md\", \"types.md\", \"arbitrage.md\", \"datafeeds.md\"]","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The graph module of ArbX. This is where the arbitrage detection algorithms reside. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Two graphs are maintained currently: PairMultigraph and MetaDiGraph. These graphs receive price updates from the DataFeeds module, which then launches threads to detect arbitrage opportunities in both graphs as described below. The arbitrages are written to a HTTP.WebSocket server on port 8084, that listens for new client connections/subscriptions and then dumps the arbitrage in JSON format. For details on the format, check Arbitrage.extractarb.","category":"page"},{"location":"index.html#PairMultigraph","page":"Home","title":"PairMultigraph","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The PairMultigraph is a WeightedDiMultigraph with Types.PriceData weights. The graph follows an adjacency list representation where each node (an <:Integer) corresponds to a Vector{<:Integer} that represents the connections. The weighted version of the MultiDigraph, PairMultigraph, also stores a weights vector that stores PriceData structs as weights. This representation is useful for quickly accessing all connections against a certain node. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The nodes represent tokens, provided externally, and the edges represent the bid and ask connections between them across markets. Two tokens can have multiple bid and ask connections for each market that they are traded on, e.g Orca and Serum. If the edge n => m is a bid, then m => n is necessarily ask; this similarly applies in case of multiple connections, in which case an invocation to weights(graph, n, m) will return a vector of PriceData each of which will have side == bid. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Ultimately, this helps in finding cross-market arbitrage opportunities quickly. If a price update is received on two tokens, n and m, then accessing the weights for each direction (n => m and m => n) returns the bids and asks respectively for the tokens across markets. If the maximum bid is higher than the minimum ask, then we have an opportunity where we can buy low and sell high. ","category":"page"},{"location":"index.html#MetaDiGraph","page":"Home","title":"MetaDiGraph","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"For finding arbitrages that involve more than one trade/swap, we need a different data structure. MetaDiGraph provides the required versatility and performance. Summarily, the Meta in the name only means that meta data can be stored on any node or edge in the graph. Internally, the data is stored in Dict structures that provide fast access to data. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Unlike PairMultigraph, MetaDiGraph does not allow multiple connections between any two nodes. This restricts us to store only the best prices between two tokens – which is exactly what we want. Using Arbitrage.bellman_ford_return_cycle we can find negative-weight cycles in the graph, which simply put means you can trade/swap across the cycle and end up with a greater amount than what you started with. For more details, see Arbitrage.calculate_profit_potential. ","category":"page"},{"location":"index.html#Appendix","page":"Home","title":"Appendix","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Refer to publisher.jl for launch details. ","category":"page"},{"location":"datafeeds.html","page":"DataFeeds","title":"DataFeeds","text":"CurrentModule = ArbX.DataFeeds","category":"page"},{"location":"datafeeds.html#DataFeeds","page":"DataFeeds","title":"DataFeeds","text":"","category":"section"},{"location":"datafeeds.html","page":"DataFeeds","title":"DataFeeds","text":"Documentation for ArbX.","category":"page"},{"location":"datafeeds.html","page":"DataFeeds","title":"DataFeeds","text":"Pages = [\"datafeeds.md\"]","category":"page"},{"location":"datafeeds.html","page":"DataFeeds","title":"DataFeeds","text":"Modules = [DataFeeds]","category":"page"},{"location":"datafeeds.html#ArbX.DataFeeds.feed-Union{Tuple{T}, Tuple{T, Vararg{Any}}} where T<:ArbX.DataFeeds.DataFeed","page":"DataFeeds","title":"ArbX.DataFeeds.feed","text":"feed(d::T, args...; kwargs...) where T <: DataFeed\n\nOpen a WebSocket or Redpanda connection to listen to the price feeds for a DataFeed.\n\nFor each update on the connection, execute the functions passed via args.... The args... are executed via  foldr so the argument-ordering matters; each subsequent function expects a parameter of the type returned by  the antecedent. \n\n\n\n\n\n","category":"method"},{"location":"datafeeds.html#ArbX.DataFeeds.validatepairs-Tuple{T} where T<:ArbX.DataFeeds.DataFeed","page":"DataFeeds","title":"ArbX.DataFeeds.validatepairs","text":"validatepairs(::T; mkts::Vector{<:AbstractString})::Vector{<:AbstractString} where T <: DataFeed -> Vector{<:AbstractString}\n\nValidate the markets passed in via mkts corresponding to the DataFeed passed in the first parameter. \n\nThis is to eliminate any inactive pair from the market. The returned Vector should contain active pairs only.\n\n\n\n\n\n","category":"method"},{"location":"types.html","page":"Types","title":"Types","text":"CurrentModule = ArbX.Types","category":"page"},{"location":"types.html#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"Documentation for ArbX.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"Pages = [\"types.md\"]","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"Modules = [Types]","category":"page"},{"location":"types.html#ArbX.Types.DataPacket","page":"Types","title":"ArbX.Types.DataPacket","text":"DataPacket\n\nData format for price updates received by feed. The graph setindex! method expects  updates in DataPacket format. \n\n\n\n\n\n","category":"type"},{"location":"types.html#ArbX.Types.PairMultigraph","page":"Types","title":"ArbX.Types.PairMultigraph","text":"PairMultigraph\n\nWeightedDiMultigraph specialized for PriceData edges. \n\n\n\n\n\n","category":"type"},{"location":"types.html#ArbX.Types.PriceData","page":"Types","title":"ArbX.Types.PriceData","text":"PriceData\n\nData format for PairMultigraph edges. \n\n\n\n\n\n","category":"type"}]
}
